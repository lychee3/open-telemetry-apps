"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstrumentationBase = void 0;
const path = require("path");
const RequireInTheMiddle = require("require-in-the-middle");
const semver = require("semver");
const instrumentation_1 = require("../../instrumentation");
const api_1 = require("@opentelemetry/api");
/**
 * Base abstract class for instrumenting node plugins
 */
class InstrumentationBase extends instrumentation_1.InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config = {}) {
        super(instrumentationName, instrumentationVersion, config);
        this._hooks = [];
        this._enabled = false;
        let modules = this.init();
        if (modules && !Array.isArray(modules)) {
            modules = [modules];
        }
        this._modules = modules || [];
        if (this._modules.length === 0) {
            api_1.diag.warn('No modules instrumentation has been defined,' +
                ' nothing will be patched');
        }
        if (this._config.enabled) {
            this.enable();
        }
    }
    _isSupported(name, version) {
        for (const module of this._modules) {
            if (module.name === name) {
                if (!module.supportedVersions) {
                    return true;
                }
                return module.supportedVersions.some(supportedVersion => {
                    return semver.satisfies(version, supportedVersion);
                });
            }
        }
        return false;
    }
    _onRequire(module, exports, name, baseDir) {
        var _a;
        if (!baseDir) {
            if (typeof module.patch === 'function') {
                module.moduleExports = exports;
                return module.patch(exports);
            }
            return exports;
        }
        const version = require(path.join(baseDir, 'package.json')).version;
        module.moduleVersion = version;
        if (module.name === name) {
            // main module
            if (typeof version === 'string' && this._isSupported(name, version)) {
                if (typeof module.patch === 'function') {
                    module.moduleExports = exports;
                    if (this._enabled) {
                        return module.patch(exports, module.moduleVersion);
                    }
                }
            }
        }
        else {
            // internal file
            const files = (_a = module.files) !== null && _a !== void 0 ? _a : [];
            const file = files.find(file => file.name === name);
            if (file &&
                file.supportedVersions.some(supportedVersion => semver.satisfies(version, supportedVersion))) {
                file.moduleExports = exports;
                if (this._enabled) {
                    return file.patch(exports, module.moduleVersion);
                }
            }
        }
        return exports;
    }
    enable() {
        if (this._enabled) {
            return;
        }
        this._enabled = true;
        // already hooked, just call patch again
        if (this._hooks.length > 0) {
            for (const module of this._modules) {
                if (typeof module.patch === 'function' && module.moduleExports) {
                    module.patch(module.moduleExports, module.moduleVersion);
                }
                for (const file of module.files) {
                    if (file.moduleExports) {
                        file.patch(file.moduleExports, module.moduleVersion);
                    }
                }
            }
            return;
        }
        for (const module of this._modules) {
            this._hooks.push(RequireInTheMiddle([module.name], { internals: true }, (exports, name, baseDir) => {
                return this._onRequire(module, exports, name, baseDir);
            }));
        }
    }
    disable() {
        if (!this._enabled) {
            return;
        }
        this._enabled = false;
        for (const module of this._modules) {
            if (typeof module.unpatch === 'function' && module.moduleExports) {
                module.unpatch(module.moduleExports, module.moduleVersion);
            }
            for (const file of module.files) {
                if (file.moduleExports) {
                    file.unpatch(file.moduleExports, module.moduleVersion);
                }
            }
        }
    }
}
exports.InstrumentationBase = InstrumentationBase;
//# sourceMappingURL=instrumentation.js.map