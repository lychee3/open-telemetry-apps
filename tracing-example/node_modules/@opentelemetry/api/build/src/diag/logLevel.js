"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLogLevelDiagLogger = exports.DiagLogLevel = void 0;
var diag_1 = require("../api/diag");
var logger_1 = require("./logger");
/**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */
var DiagLogLevel;
(function (DiagLogLevel) {
    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
    DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
    /** Identifies an error scenario */
    DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
    /** Identifies a warning scenario */
    DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
    /** General informational log message */
    DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
    /** General debug log message */
    DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
    /**
     * Detailed trace level logging should only be used for development, should only be set
     * in a development environment.
     */
    DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
    /** Used to set the logging level to include all logging */
    DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
})(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
/** Mapping from DiagLogger function name to logging level. */
var levelMap = [
    { n: 'error', l: DiagLogLevel.ERROR },
    { n: 'warn', l: DiagLogLevel.WARN },
    { n: 'info', l: DiagLogLevel.INFO },
    { n: 'debug', l: DiagLogLevel.DEBUG },
    { n: 'verbose', l: DiagLogLevel.VERBOSE },
];
/**
 * Create a Diagnostic logger which limits the messages that are logged via the wrapped logger based on whether the
 * message has a {@link DiagLogLevel} equal to the maximum logging level or lower, unless the {@link DiagLogLevel} is
 * NONE which will return a noop logger instance. This can be useful to reduce the amount of logging used for the
 * system or for a specific component based on any local configuration.
 * If you don't supply a logger it will use the global api.diag as the destination which will use the
 * current logger and any filtering it may have applied.
 * To avoid / bypass any global level filtering you should pass the current logger returned via
 * api.diag.getLogger() however, any changes to the logger used by api.diag won't be reflected for this case.
 * @param maxLevel - The max level to log any logging of a lower
 * @param logger - The specific logger to limit, if not defined or supplied will default to api.diag
 * @implements {@link DiagLogger}
 * @returns {DiagLogger}
 */
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
    }
    else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
    }
    if (maxLevel === DiagLogLevel.NONE) {
        return logger_1.createNoopDiagLogger();
    }
    if (!logger) {
        logger = diag_1.DiagAPI.instance();
    }
    function _filterFunc(theLogger, funcName, theLevel) {
        if (maxLevel >= theLevel) {
            return function () {
                var orgArguments = arguments;
                var theFunc = theLogger[funcName];
                if (theFunc && typeof theFunc === 'function') {
                    return theFunc.apply(logger, orgArguments);
                }
            };
        }
        return function () { };
    }
    var newLogger = {};
    for (var i = 0; i < levelMap.length; i++) {
        var name_1 = levelMap[i].n;
        newLogger[name_1] = _filterFunc(logger, name_1, levelMap[i].l);
    }
    return newLogger;
}
exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
//# sourceMappingURL=logLevel.js.map